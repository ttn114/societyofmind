<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Society of Mind</title>
    <link rel="stylesheet" href="stylesheet.css" type="text/css" />


</head>
<body>
<h2>7.4 problem solving</h2>

    <p>
      In principle, we can use the <em>generate and test</em> method &mdash;
      that is, trial and error &mdash; to solve any problem whose solution we
      can recognize.  But in practice, it can take too long for even the most
      powerful computer to test enough possible solutions. Merely assembling a
      simple house from a dozen wooden blocks would require searching through
      more possibilities than a child could try in a lifetime. Here is one way
      to improve upon blind trial-and-error search.</p>

    <p>
      The Progress Principle: Any process of exhaustive search can be greatly
      reduced if we possess some way to detect when <em>progress</em> has been
      made. Then we can trace a path toward a solution, just as a person can
      climb an unfamiliar hill in the dark &mdash; by feeling around, at every
      step, to find the direction of steepest ascent.</p>

    <p>
      Many easy problems can be solved this way, but for a hard
      problem, it may be almost as difficult to
      recognize <em>progress</em> as to solve the problem
      itself. Without a larger overview, that <em>hill climber</em>
      may get stuck forever on some minor peak and never find the
      mountaintop.  There is no foolproof way to avoid this.</p>

    <p>
      Goals and Subgoal: The most powerful way we know for discovering how to
      solve a hard problem is to find a method that splits it into several
      simpler ones, each of which can be solved separately.</p>

    <p>
      Much research in the field called Artificial Intelligence has been
      concerned with finding methods machines can use for splitting a problem
      into smaller subproblems and then, if necessary, dividing these into yet
      smaller ones. In the next few sections we&#39;ll see how this can be
      done by formulating our problems in terms of <em>goals.</em></p>

    <p>
      Using Knowledge: The most efficient way to solve a problem is to already
      know how to solve it. Then one can avoid search entirely.</p>

    <p>
      Accordingly, another branch of Artificial Intelligence research has
      sought to find ways to embody knowledge in machines. But this problem
      itself has several parts: we must discover how to acquire the knowledge
      we need, we must learn how to represent it, and, finally, we must
      develop processes that can exploit our knowledge effectively.  To
      accomplish all that, our memories must represent, in preference to vast
      amounts of small details, only those relationships that may help us
      reach our goals. This research has led to many practical
      <em>knowledge-based</em> problem-solving systems. Some of these are
      often called <em>expert systems</em> because they&#39;re based on
      imitating the methods of particular human practitioners.</p>

    <p>
      A curious phenomenon emerged from this research. It often turned out
      easier to program machines to solve specialized problems that educated
      people considered hard &mdash; such as playing chess or proving theorems
      about logic or geometry &mdash; than to make machines do things that
      most people considered easy &mdash; such as building toy houses with
      children&#39;s blocks. This is why I&#39;ve emphasized so
      many <em>easy</em> problems in this book.</p>
</body>
</html>
