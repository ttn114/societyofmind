<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Society of Mind</title>
    <link rel="stylesheet" href="stylesheet.css" type="text/css" />


</head>
<body>
<h2>3.4 Heterarchies</h2>

    <p>
      A hierarchical society is like a tree in which the agent at each branch
      is exclusively responsible for the agents on the twigs that branch from
      it. This pattern is found in every field, because dividing work into
      parts like that is usually the easiest way to start solving a
      problem. It is easy to construct and understand such organizations
      because each agent has only a single job to do: it needs only
      to <em>look up</em> for instructions from its supervisor, then <em>look
        down</em> to get help from its subordinates.</p>

    <p>
      But hierarchies do not always work. Consider that when two agents need
      to use each other&#39;s skills, then neither one can be <em>on top.</em>
      Notice what happens, for example, when you ask your vision-system to
      decide whether the following left-side scene depicts three blocks
      &mdash; or only two.</p>
    <img class="illus" src="./illus/ch3/3-3.png"/>
	
    <p>
      The agent See could answer that if it could Move the front block out of
      the line of view. But, in the course of doing that, Move might have to
      See if there were any obstacles that might interfere with the arm&#39;s
      trajectory. At such a moment, Move would be working for See, and See
      would be working for Move, both at the same time. This would be
      impossible inside a simple hierarchy.</p>

    <p>
      Most of the diagrams in the early parts of this book depict simple
      hierarchies. Later, we&#39;ll see more cross-connected rings and loops
      &mdash; when we are forced to consider the need for memory, which will
      become a constant subject of concern in this book. People often think of
      memory in terms of keeping records of the past, for recollecting things
      that happened in earlier times. But agencies also need other kinds of
      memory as well. See, for example, requires some sort of temporary memory
      in order to keep track of what next to do, when it starts one job before
      its previous job is done. If each of See&#39;s agents could do only one
      thing at a time, it would soon run out of resources and be unable to
      solve complicated problems. But if we have enough memory, we can arrange
      our agents into circular loops and thus use the same agents over and
      over again to do parts of several different jobs at the same time.</p>
</body>
</html>
